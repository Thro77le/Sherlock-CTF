pragma solidity 0.8.11;

interface IBitMania {
    function encryptFlag(string memory stringFlag) external pure returns (bytes memory);
    function solveIt(string memory flag) external;
}

contract Exploit {
    bytes public constant encFlag = bytes(hex"6e3c5b0f722c430e6d324c0d6f67173d4b1565345915753504211f");

    constructor(IBitMania bit_mania) payable {
        bytes memory result = new bytes(encFlag.length);

        for (uint256 i; i < encFlag.length; i++) {
            bytes1 a = encFlag[i];

            for (uint8 j; j < 256; ++j) {
                bytes1 x;
                if (i > 0) {
                    x = bytes1(j) ^ encFlag[i-1];
                } else {
                    x = bytes1(j);
                }

                x ^= x >> 4;
                x ^= x >> 3;
                x ^= x >> 2;
                x ^= x >> 1;
                if (x == a) {
                    result[i] = bytes1(j);
                    break;
                }
            }
        }
        bit_mania.solveIt(string(result));
    }
}